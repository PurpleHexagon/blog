{"componentChunkName":"component---plugins-gatsby-theme-sky-lite-src-templates-post-js","path":"/posts/sliding-puzzle-1/","result":{"data":{"mdx":{"body":"var _excluded = [\"components\"];\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n/* @jsxRuntime classic */\n/* @jsx mdx */\n\nvar _frontmatter = {\n  \"id\": \"sliding-puzzle-1\",\n  \"title\": \"Building a sliding puzzle (Part 1 - Backend)\",\n  \"author\": \"JonDay\",\n  \"featuredImage\": \"black-and-white-blank-challenge-connect-262488.jpg\",\n  \"tags\": [\"php\", \"puzzle\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n    props = _objectWithoutProperties(_ref, _excluded);\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"In this blog post I will explore creating backend logic for a sliding puzzle game. This project was started on a train with no internet connection and the idea then later expanded upon.\"), mdx(\"p\", null, \"I liked the sound of building this as I wanted to explore the capabilities of NumPHP, and I thought this would be a good testing ground.\"), mdx(\"p\", null, \"Currently the NumPHP matrix is only used to store which tile is empty and which are not. Reflecting on this though I believe this data structure could be used to hold all information about the state of the puzzle.\"), mdx(\"p\", null, \"One thing that became quickly obvious about my original code was that when the tiles are shuffled randomly the puzzle was not always solvable.\"), mdx(\"p\", null, \"Rather than hard coding a specific set of starting tiles I decided to find out what rules a puzzle needed to adhere to, to be solvable. It turned out this mainly came down the grid size, the number of inversions and where the empty tile is.\"), mdx(\"h2\", null, \"The finished code:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-php\"\n  }, \"<?php declare(strict_types=1);\\nnamespace PurpleHexagon\\\\Services\\\\Puzzle;\\n\\nuse LogicException;\\nuse RuntimeException;\\nuse NumPHP\\\\Core\\\\NumArray;\\n\\n/**\\n * Encapsulates logic for sliding puzzles\\n *\\n * Class PuzzleEngine\\n * @package PurpleHexagon\\\\Services\\\\Puzzle\\n */\\nclass PuzzleEngine\\n{\\n    /**\\n     * The size of the puzzle, i.e. 9 or 16\\n     * @var int\\n     */\\n    protected $puzzleSize;\\n\\n    /**\\n     * The size of one dimension of the puzzle, a puzzle of size 9 will have\\n     * a dimension of 3 for example\\n     * @var int\\n     */\\n    protected $dimension;\\n\\n    /**\\n     * Instance of NumArray representing the puzzle tile positions as a matrix\\n     * which will be initialised with a multidimentional array\\n     *\\n     * Example of a solved puzzle:\\n     * [\\n     *     [1, 1, 1],\\n     *     [1, 1, 1],\\n     *     [1, 1, 0],\\n     * ]\\n     *\\n     * @var array\\n     */\\n    protected $puzzleMatrix;\\n\\n    /**\\n     * A shuffled array of tile indexes to be mutated as the puzzle is played\\n     * @var array\\n     */\\n    protected $tiles = [];\\n\\n    /**\\n     * Holds the solution for the puzzle, i.e. the tiles in the correct order\\n     * @var array\\n     */\\n    protected $solution = [];\\n\\n    /**\\n     * Whether the puzzle has been solved\\n     * @var boolean\\n     */\\n    protected $isSolved = false;\\n\\n    /**\\n     * Ensures the puzzle size is a square number. If it is then initialise tiles\\n     * and solution properties to an array of indexes. Then mutates the tiles\\n     * property using shuffle for psuedo random puzzle start point.\\n     *\\n     * Then initialises a matrix with the final element set to 0 as the last\\n     * tile will always be empty.\\n     *\\n     * @param int $puzzleSize\\n     */\\n    public function __construct(int $puzzleSize)\\n    {\\n        $this->ensureIsSquareGuard($puzzleSize);\\n        $this->tiles = $this->solution = range(1, $puzzleSize);\\n        $this->puzzleSize = $puzzleSize;\\n        $this->dimension = (int) sqrt($puzzleSize);\\n\\n        $this->shuffle();\\n        while ($this->ensurePuzzleIsSolvable() === false) {\\n            $this->shuffle();\\n        }\\n\\n        foreach (range(1, $this->dimension) as $index) {\\n            $puzzleRow = array_fill(0, $this->dimension, 1);\\n            if ($index == $this->dimension) $puzzleRow[$index - 1] = 0;\\n            $puzzleAsMultiDimensionalArray[] = $puzzleRow;\\n        }\\n\\n        $this->puzzleMatrix = new NumArray(\\n            $puzzleAsMultiDimensionalArray\\n        );\\n    }\\n\\n    /**\\n     * Shuffle the tiles and set last tile value to the final value for puzzle size, ie 9 for size 9 puzzle\\n     */\\n    protected function shuffle()\\n    {\\n        $finalTileValue = pow($this->dimension, 2);\\n        $lastTileIndex = $finalTileValue - 1;\\n\\n        shuffle($this->tiles);\\n        $lastTile = $this->tiles[$lastTileIndex];\\n        $this->tiles = array_map(\\n            function ($value) use ($lastTile, $finalTileValue) {\\n                if ($value === $finalTileValue) {\\n                    return $lastTile;\\n                }\\n\\n                return $value;\\n            },\\n            $this->tiles\\n        );\\n\\n        $this->tiles[$lastTileIndex] = $finalTileValue;\\n    }\\n\\n    /**\\n     * Return the tiles\\n     * @return array\\n     */\\n    public function getTiles()\\n    {\\n        return $this->tiles;\\n    }\\n\\n    /**\\n     * Return the tiles\\n     * @return array\\n     */\\n    public function getPuzzleMatrix()\\n    {\\n        return $this->puzzleMatrix;\\n    }\\n\\n    /**\\n     * Update the puzzle matrix and tile properties which represents a move\\n     * @param  int      $from\\n     * @param  int      $to\\n     * @return bool\\n     */\\n    public function move(int $from, int $to): bool\\n    {\\n        $this->isValidIndexForMove($from, $to);\\n\\n        $move = $this->createMoveMatrix($from, $to);\\n        $newPuzzleMatrix = $this->puzzleMatrix->add($move);\\n        $this->ensureMoveValid($newPuzzleMatrix->getData());\\n        $this->puzzleMatrix = $newPuzzleMatrix;\\n\\n        $fromValue = $this->tiles[$from - 1];\\n        $toValue = $this->tiles[$to - 1];\\n        $this->tiles[$from - 1] = $toValue;\\n        $this->tiles[$to - 1] = $fromValue;\\n\\n        if ($this->tiles === $this->solution) {\\n            $this->isSolved = true;\\n        } else {\\n            $this->isSolved = false;\\n        }\\n\\n        return $this->isSolved;\\n    }\\n\\n    /**\\n     * Returns false if the puzzle is not solvable\\n     *\\n     * Rules:\\n     *\\n     * If the grid width is odd, then the number of inversions in a solvable situation is even.\\n     * If the grid width is even, and the blank is on an even row counting from the bottom (second-last, fourth-last etc), then the number of inversions in a solvable situation is odd.\\n     * If the grid width is even, and the blank is on an odd row counting from the bottom (last, third-last, fifth-last etc) then the number of inversions in a solvable situation is even.\\n     *\\n     * Since the last tile is always the empty tile in this implementation rule two has not been implemented\\n     *\\n     * @return bool\\n     */\\n    protected function ensurePuzzleIsSolvable()\\n    {\\n        $inversions = $this->calculateInversions();\\n\\n        if (($this->dimension % 2 !== 0) && ($inversions % 2 === 0)) {\\n            return true;\\n        }\\n\\n        if (($this->dimension % 2 === 0) && ($inversions % 2 === 0)) {\\n            return true;\\n        }\\n\\n        return false;\\n    }\\n\\n\\n    /**\\n     * Calculate inversions for current tiles\\n     *\\n     * An inversion is when a tile precedes another tile with a lower number on it.\\n     *\\n     * Total inversions is the count of all tiles with lower value for every tile\\n     *\\n     * @return int|mixed\\n     */\\n    protected function calculateInversions()\\n    {\\n        $inversions = 0;\\n\\n        foreach ($this->tiles as $outerTileIndex => $outerTile) {\\n            foreach ($this->tiles as $innerTileIndex => $innerTile) {\\n                if ($innerTileIndex < $outerTileIndex) {\\n                    continue;\\n                }\\n\\n                if ($outerTile === $innerTile || $innerTile > $outerTile) {\\n                    continue;\\n                }\\n\\n                $inversions += 1;\\n            }\\n        }\\n\\n        return $inversions;\\n    }\\n\\n    /**\\n     * Check if puzzleSize is a square number and throw exception if not\\n     * @param  int    $puzzleSize\\n     * @throws LogicException\\n     */\\n    protected function ensureIsSquareGuard(int $puzzleSize)\\n    {\\n        $squareRootOfPuzzleSize = sqrt($puzzleSize);\\n        $remainder = fmod($squareRootOfPuzzleSize, 1);\\n\\n        // $remainder will be set to float(0) if the puzzle size is a square number\\n        // and want to use strict type checking\\n        if ($remainder !== 0.0) {\\n            throw new LogicException(\\n                sprintf(\\n                    \\\"%s::%s - Puzzles must be a square, please provide a valid puzzle size\\\",\\n                    __CLASS__,\\n                    __FUNCTION__\\n                )\\n            );\\n        }\\n    }\\n\\n    /**\\n     * Step through the multidimensional array and ensure there are no elements\\n     * with a value of 2, as this would mean the tile being moved to is occupied\\n     * @param array $puzzle    Puzzle matrix in multidimentional array form\\n     */\\n    protected function ensureMoveValid(array $puzzle)\\n    {\\n        array_walk_recursive($puzzle, function ($item, $key) {\\n            if ($item === 2 || $item === -1) {\\n                throw new RuntimeException(\\n                    sprintf(\\n                        \\\"%s::%s - Invalid move made, cannot move to occupied square\\\",\\n                        __CLASS__,\\n                        __FUNCTION__\\n                    )\\n                );\\n            }\\n        });\\n    }\\n\\n    /**\\n     * Returns an array where the first element is the row position and the\\n     * second element is the index in that row\\n     * @param  int    $moveValue\\n     * @return array\\n     */\\n    protected function getPosition(int $moveValue): array\\n    {\\n      $rowPositionMagnitude = (int) ($moveValue / $this->dimension);\\n\\n      if ($moveValue % $this->dimension !== 0) $rowPosition = $rowPositionMagnitude + 1;\\n      else $rowPosition = $rowPositionMagnitude;\\n\\n      $indexPosition = (int) ($moveValue - (($rowPosition - 1) * $this->dimension));\\n\\n      return [$rowPosition, $indexPosition];\\n    }\\n\\n    /**\\n     * Initialises and returns a matrix which represents a move\\n     *\\n     * Example move from tile 9 to tile 6:\\n     *\\n     *   0  0  0\\n     *   0  0 -1\\n     *   0  0  1\\n     *\\n     * @param  int      $from         A tile index to move from\\n     * @param  int      $to           A tile index to move to\\n     * @return NumArray $moveMatrix   Move represented as matrix\\n     */\\n    protected function createMoveMatrix(int $from, int $to): NumArray\\n    {\\n        $moveArray = [];\\n        $fromPosition = $this->getPosition($from);\\n        $toPosition = $this->getPosition($to);\\n\\n        $this->adjacestTileGuard($fromPosition, $toPosition);\\n\\n\\n        // Iterate by dimension to generate each puzzle row, check when\\n        // the iteration is for a row that has been updated and then\\n        // set the correct element/s in row for from and to move\\n        foreach (range(1, $this->dimension) as $rowIndex) {\\n            $puzzleRow = array_fill(0, $this->dimension, 0);\\n            if ($rowIndex === $fromPosition[0]) $puzzleRow[$fromPosition[1] - 1] = -1;\\n            if ($rowIndex === $toPosition[0]) $puzzleRow[$toPosition[1] - 1] = 1;\\n\\n            $moveArray[] = $puzzleRow;\\n        }\\n\\n        $moveMatrix = new NumArray(\\n            $moveArray\\n        );\\n\\n        return $moveMatrix;\\n    }\\n\\n    /**\\n     * Guard against being able to make illegal moves across more than one tile\\n     * @param  array $fromPosition\\n     * @param  array $toPosition\\n     * @throws RuntimeException\\n     */\\n    protected function adjacestTileGuard(array $fromPosition, array $toPosition)\\n    {\\n        // If move is in the same row the position indexes should only be one apart\\n        if ($fromPosition[0] === $toPosition[0]) {\\n            if (abs($fromPosition[1] - $toPosition[1]) !== 1) {\\n                throw new RuntimeException(\\n                    sprintf(\\n                        \\\"%s::%s - Invalid move made, those squares arent together!\\\",\\n                        __CLASS__,\\n                        __FUNCTION__\\n                    )\\n                );\\n            }\\n        }\\n\\n        // If move it in adjacent row then column permissions must be the same\\n        if (abs($fromPosition[0] - $toPosition[0]) === 1) {\\n            if ($fromPosition[1] !== $toPosition[1]) {\\n                throw new RuntimeException(\\n                    sprintf(\\n                        \\\"%s::%s - Invalid move made, those squares arent together!\\\",\\n                        __CLASS__,\\n                        __FUNCTION__\\n                    )\\n                );\\n            }\\n        }\\n\\n        // If move is greater than one row apart then you can never do this\\n        if (abs($fromPosition[0] - $toPosition[0]) > 1) {\\n            throw new RuntimeException(\\n                sprintf(\\n                    \\\"%s::%s - Invalid move made, those squares arent together!\\\",\\n                    __CLASS__,\\n                    __FUNCTION__\\n                )\\n            );\\n        }\\n    }\\n\\n    /**\\n     * Ensure the index is valid for the puzzle size\\n     *\\n     * @param int $from\\n     * @param int $to\\n     */\\n    protected function isValidIndexForMove(int $from, int $to)\\n    {\\n        $indexes = range(1, $this->puzzleSize);\\n\\n        if (in_array($from, $indexes) === false) {\\n            throw new RuntimeException(\\\"Move index is not valid\\\");\\n        }\\n\\n        if (in_array($to, $indexes) === false) {\\n            throw new RuntimeException(\\\"Move index is not valid\\\");\\n        }\\n    }\\n\\n    /**\\n     * Getter for isSolved class property\\n     * @return bool    True if the puzzle is solved\\n     */\\n    public function getIsSolved(): bool\\n    {\\n        return $this->isSolved;\\n    }\\n}\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"id":"sliding-puzzle-1","title":"Building a sliding puzzle (Part 1 - Backend)","tags":["php","puzzle"],"featuredImage":{"childImageSharp":{"fluid":{"base64":"data:image/jpeg;base64,/9j/2wBDAAgGBgcGBQgHBwcJCQgKDBQNDAsLDBkSEw8UHRofHh0aHBwgJC4nICIsIxwcKDcpLDAxNDQ0Hyc5PTgyPC4zNDL/2wBDAQkJCQwLDBgNDRgyIRwhMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjL/wgARCAAPABQDASIAAhEBAxEB/8QAFwAAAwEAAAAAAAAAAAAAAAAAAAIFBv/EABQBAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhADEAAAAdrGqAwof//EABkQAQACAwAAAAAAAAAAAAAAAAAEEQEUIf/aAAgBAQABBQJJn60lbmVv/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPwE//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPwE//8QAGhAAAgMBAQAAAAAAAAAAAAAAAAECAyEQQv/aAAgBAQAGPwIrqdbcZeu6jT//xAAbEAEAAgMBAQAAAAAAAAAAAAABADERQVFhwf/aAAgBAQABPyEZuSMfO6jcr5EQwKUpUwz1P//aAAwDAQACAAMAAAAQUw//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/ED//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/ED//xAAcEAEBAAMBAAMAAAAAAAAAAAABEQAxUSFBkcH/2gAIAQEAAT8Qshbr3mLEZ+UukGlX1YVuN4+9YCkWdncYa9IYns/e41eu8//Z","aspectRatio":1.3333333333333333,"src":"/static/574dc13ec2bc4f3caa719b6b60889363/356ef/black-and-white-blank-challenge-connect-262488.jpg","srcSet":"/static/574dc13ec2bc4f3caa719b6b60889363/107df/black-and-white-blank-challenge-connect-262488.jpg 320w,\n/static/574dc13ec2bc4f3caa719b6b60889363/38a09/black-and-white-blank-challenge-connect-262488.jpg 640w,\n/static/574dc13ec2bc4f3caa719b6b60889363/356ef/black-and-white-blank-challenge-connect-262488.jpg 1280w,\n/static/574dc13ec2bc4f3caa719b6b60889363/4fb49/black-and-white-blank-challenge-connect-262488.jpg 1920w,\n/static/574dc13ec2bc4f3caa719b6b60889363/afdd3/black-and-white-blank-challenge-connect-262488.jpg 2560w,\n/static/574dc13ec2bc4f3caa719b6b60889363/794d3/black-and-white-blank-challenge-connect-262488.jpg 3648w","sizes":"(max-width: 1280px) 100vw, 1280px"}}}}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"postId":"sliding-puzzle-1","postDate":"2020-04-22","previousPath":"/posts/fast-jsonapi-1","nextPath":"/posts/cosine-haversine"}}}