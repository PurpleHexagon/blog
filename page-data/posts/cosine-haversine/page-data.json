{"componentChunkName":"component---src-gatsby-theme-sky-lite-templates-post-js","path":"/posts/cosine-haversine","result":{"data":{"mdx":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"id\": \"cosine-haversine\",\n  \"title\": \"Cosine Haversine formula in Rust\",\n  \"author\": \"JonDay\",\n  \"featuredImage\": \"silhouette-of-airplane-during-sunset-99567.jpg\",\n  \"tags\": [\"rust\", \"algorithms\"]\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"I recently had to work with an implementation of Cosine Haversine formula in Javascript. I decided I wanted to understand how this worked in more detail, so reimplemented the algorithm in Rust to perform some tests.\"), mdx(\"p\", null, \"The formula is as follows:\\n=ACOS(COS(RADIANS(90-DLAT)) \", \"*\", \" COS(RADIANS(90-ALAT)) \", \"+\", \" SIN(RADIANS(90-DLAT)) \", \"*\", \" SIN(RADIANS(90-ALAT)) \", \"*\", \" COS(RADIANS(DLNG-ALNG))) \", \"*\", \" 6371\"), mdx(\"h3\", null, \"Implemtation in Rust:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-rust\"\n  }), \"fn main() {\\n    let departure_lat: f64 = 48.35;\\n    let departure_lng: f64 = 11.79;\\n    let arrival_lat: f64 = 51.48;\\n    let arrival_lng: f64 = -0.46;\\n\\n    let part_one: f64 = (90.0 - departure_lat).to_radians().cos() * (90.0 - arrival_lat).to_radians().cos();\\n    let part_two: f64 = (90.0 - departure_lat).to_radians().sin() * (90.0 - arrival_lat).to_radians().sin() * (departure_lng - arrival_lng).to_radians().cos();\\n\\n    let result = (part_one + part_two).acos() * 6371.0;\\n\\n    println!(\\\"Distance in km: {:.2}\\\", result);\\n}\\n\\n\")), mdx(\"h3\", null, \"Output:\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"jon@PurpleHexagon:~/code/rust/haversine$ cargo run\\nCompiling haversine v0.1.0 (/home/jon/code/rust/haversine)\\nFinished dev \", \"[unoptimized + debuginfo]\", \" target(s) in 0.36s\\nRunning \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"target/debug/haversine\"), \"\\nDistance in km: 942.20\")), mdx(\"h3\", null, \"More:\"), mdx(\"p\", null, \"The word Haversine comes from another trigonometric function, much like the well known sine, cosine and, tangent.\"), mdx(\"p\", null, \"This formula will calculate the great-circle distance between two points. That is the shortest distance between two points. So if you were to fly between LA and New York it would calculate the distance as if you were flying across the USA not flying all the way round the world. To use this function the latitude and longitude of the departure and arrival locations are required.\"), mdx(\"p\", null, \"Using the formula becomes more important over longer distances where the curvature of the earth will have more impact.\"), mdx(\"p\", null, \"Whilst this is only a rough approximation, as it does not take into account flight plans or earth\\u2019s topology, it is still very useful when calculating distances on a curved plane.\"));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"id":"cosine-haversine","title":"Cosine Haversine formula in Rust","tags":["rust","algorithms"],"featuredImage":{"childImageSharp":{"fluid":{"base64":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAANABQDASIAAhEBAxEB/8QAGAAAAwEBAAAAAAAAAAAAAAAAAAMFAgT/xAAVAQEBAAAAAAAAAAAAAAAAAAAAA//aAAwDAQACEAMQAAABWyfqFOomh//EABoQAQEAAgMAAAAAAAAAAAAAAAIBAAMREhP/2gAIAQEAAQUCOwHNO8IqjkvrnpRK7c//xAAWEQEBAQAAAAAAAAAAAAAAAAAAERL/2gAIAQMBAT8BrT//xAAXEQADAQAAAAAAAAAAAAAAAAAAAQIS/9oACAECAQE/AVKMH//EAB4QAAIBAwUAAAAAAAAAAAAAAAABAhEhkQMiMTJR/9oACAEBAAY/ArywhrUcq18OxY2uWTln/8QAHBABAAICAwEAAAAAAAAAAAAAAQARMUEhYXGh/9oACAEBAAE/Id1dWTk0GnANTBKogyPGDgIW2Fr+k//aAAwDAQACAAMAAAAQi8//xAAYEQEBAAMAAAAAAAAAAAAAAAABABExUf/aAAgBAwEBPxBTpsOX/8QAGBEAAwEBAAAAAAAAAAAAAAAAAAERIVH/2gAIAQIBAT8Q0VUT9P/EABsQAQACAwEBAAAAAAAAAAAAAAEAESExUUGh/9oACAEBAAE/EFS+qWpB2FBYO+E1EtZ4cy3N18CvkWroCtrvRH7setn/2Q==","aspectRatio":1.5854141894569957,"src":"/static/c8b738cffd33fba4aea0bf2042a63eb6/c108b/silhouette-of-airplane-during-sunset-99567.jpg","srcSet":"/static/c8b738cffd33fba4aea0bf2042a63eb6/7dae8/silhouette-of-airplane-during-sunset-99567.jpg 320w,\n/static/c8b738cffd33fba4aea0bf2042a63eb6/47052/silhouette-of-airplane-during-sunset-99567.jpg 640w,\n/static/c8b738cffd33fba4aea0bf2042a63eb6/c108b/silhouette-of-airplane-during-sunset-99567.jpg 1280w,\n/static/c8b738cffd33fba4aea0bf2042a63eb6/14dee/silhouette-of-airplane-during-sunset-99567.jpg 1920w,\n/static/c8b738cffd33fba4aea0bf2042a63eb6/cc37d/silhouette-of-airplane-during-sunset-99567.jpg 2560w,\n/static/c8b738cffd33fba4aea0bf2042a63eb6/f4afe/silhouette-of-airplane-during-sunset-99567.jpg 4000w","sizes":"(max-width: 1280px) 100vw, 1280px"}}}}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"postId":"cosine-haversine","postDate":"2020-06-12","previousPath":"/posts/sliding-puzzle-1","nextPath":null}}}